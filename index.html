<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Core Data Model Visualizer</title>
    
    <!-- External Dependencies -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    
    <style>
        /* Reset and Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f5f7;
            color: #1d1d1f;
            height: 100vh;
            overflow: hidden;
        }

        /* Header Styles */
        .app-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        .app-header h1 {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .toolbar {
            display: flex;
            gap: 0.5rem;
        }

        .toolbar button {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .toolbar button:hover {
            background: rgba(255,255,255,0.3);
        }

        /* Main Layout */
        .app-main {
            display: flex;
            height: calc(100vh - 80px);
        }

        .sidebar {
            width: 450px;
            background: white;
            border-right: 1px solid #e5e5e7;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: white;
        }

        /* File Input Section */
        .file-input {
            padding: 1.5rem;
            border-bottom: 1px solid #e5e5e7;
        }

        .drop-zone {
            border: 2px dashed #d2d2d7;
            border-radius: 8px;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            background: #f9f9fa;
        }

        .drop-zone:hover, .drop-zone.drag-over {
            border-color: #007AFF;
            background: #f0f8ff;
        }

        .drop-zone p {
            margin: 0.5rem 0;
            color: #86868b;
        }

        .drop-zone p:first-child {
            font-weight: 600;
            color: #1d1d1f;
        }

        .file-inputs {
            margin-top: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .file-inputs input[type="file"] {
            display: none;
        }

        .file-input-button {
            background: #007AFF;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .file-input-button:hover {
            background: #0056b3;
        }

        /* Entity List Section */
        .entity-list {
            flex: 1;
            padding: 1.5rem;
        }

        .entity-list h3 {
            margin-bottom: 1rem;
            color: #1d1d1f;
            font-size: 1.1rem;
        }

        .search-container {
            margin-bottom: 1rem;
        }

        .search-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #e5e5e7;
            border-radius: 6px;
            font-size: 0.9rem;
            background: #f9f9fa;
            transition: all 0.2s ease;
        }

        .search-input:focus {
            outline: none;
            border-color: #007AFF;
            background: white;
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.1);
        }

        .search-input::placeholder {
            color: #86868b;
        }

        .entity-item {
            background: #f9f9fa;
            border: 1px solid #e5e5e7;
            border-radius: 6px;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .entity-item:hover {
            background: #f0f8ff;
            border-color: #007AFF;
        }

        .entity-item.selected {
            background: #007AFF;
            color: white;
            border-color: #007AFF;
        }

        .entity-name {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .entity-info {
            font-size: 0.8rem;
            color: #86868b;
        }

        .entity-item.selected .entity-info {
            color: rgba(255,255,255,0.8);
        }

        /* View Tabs */
        .view-tabs {
            display: flex;
            background: #f9f9fa;
            border-bottom: 1px solid #e5e5e7;
        }

        .tab {
            flex: 1;
            padding: 1rem;
            background: none;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
        }

        .tab.active {
            background: white;
            color: #007AFF;
            border-bottom: 2px solid #007AFF;
        }

        .tab:hover:not(.active) {
            background: #f0f0f0;
        }

        /* View Containers */
        .view-container {
            flex: 1;
            display: none;
            overflow: auto;
        }

        .view-container.active {
            display: block;
        }

        /* Graph Container */
        #graph-container {
            position: relative;
            background: #ffffff;
        }

        #graph-container svg {
            width: 100%;
            height: 100%;
        }

        /* Graph Styles */
        .entity-node {
            cursor: pointer;
        }

        .entity-node rect {
            fill: #ffffff;
            stroke: #333333;
            stroke-width: 2;
            rx: 6;
        }

        .entity-node:hover rect {
            fill: #f0f8ff;
            stroke: #007AFF;
        }

        .entity-node.selected rect {
            fill: #007AFF;
            stroke: #005ce6;
        }

        .entity-node text {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 12px;
            pointer-events: none;
        }

        .entity-node .entity-title {
            font-weight: bold;
            font-size: 14px;
        }

        .entity-node.selected text {
            fill: white;
        }

        .entity-node .attribute {
            font-size: 11px;
            fill: #666;
        }

        .entity-node.selected .attribute {
            fill: rgba(255,255,255,0.9);
        }

        .relationship-link {
            stroke: #999;
            stroke-width: 2;
            fill: none;
            marker-end: url(#arrowhead);
        }

        .relationship-link.one-to-many {
            stroke: #007AFF;
        }

        .relationship-link.one-to-one {
            stroke: #34C759;
        }

        .relationship-link.many-to-many {
            stroke: #FF9500;
        }

        .relationship-link.selected {
            stroke: #FF3B30;
            stroke-width: 3;
        }

        /* Table View */
        #table-container {
            padding: 1.5rem;
        }

        .table-view {
            background: white;
            border: 1px solid #e5e5e7;
            border-radius: 8px;
            overflow: hidden;
        }

        .table-header {
            background: #f9f9fa;
            padding: 1rem;
            border-bottom: 1px solid #e5e5e7;
            font-weight: 600;
        }

        .table-content {
            max-height: 400px;
            overflow-y: auto;
        }

        .table-row {
            display: flex;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #f0f0f0;
        }

        .table-row:last-child {
            border-bottom: none;
        }

        .table-row:hover {
            background: #f9f9fa;
        }

        .table-cell {
            flex: 1;
            font-size: 0.9rem;
        }

        .table-cell.name {
            font-weight: 500;
        }

        .table-cell.type {
            color: #007AFF;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.8rem;
        }

        /* Loading and Error States */
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 200px;
            color: #86868b;
        }

        .error {
            background: #ffebee;
            color: #c62828;
            padding: 1rem;
            border-radius: 6px;
            margin: 1rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .app-main {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: 250px;
            }
            
            .app-header {
                padding: 1rem;
            }
            
            .app-header h1 {
                font-size: 1.2rem;
            }
            
            .toolbar {
                display: none;
            }
        }

        @media (max-width: 1024px) and (min-width: 769px) {
            .sidebar {
                width: 350px;
            }
        }
    </style>
</head>
<body>
    <header class="app-header">
        <h1>Core Data Model Visualizer</h1>
        <div class="toolbar">
            <button id="export-svg">Export SVG</button>
            <button id="export-png">Export PNG</button>
            <button id="reset-zoom">Reset View</button>
        </div>
    </header>
    
    <main class="app-main">
        <aside class="sidebar">
            <section class="file-input">
                <div id="drop-zone" class="drop-zone">
                    <p>Drag & Drop Files Here</p>
                    <p>Supports: .xcdatamodeld, .zip, .sqlite</p>
                    <div class="file-inputs">
                        <button class="file-input-button" onclick="document.getElementById('file-input').click()">
                            Select Files
                        </button>
                        <button class="file-input-button" onclick="document.getElementById('folder-input').click()">
                            Select Folder
                        </button>
                    </div>
                    <input type="file" id="file-input" multiple accept=".sqlite,.db,.zip,.xcdatamodeld">
                    <input type="file" id="folder-input" webkitdirectory>
                </div>
            </section>
            
            <section class="entity-list">
                <h3>Entities</h3>
                <div class="search-container">
                    <input 
                        type="text" 
                        id="entity-search" 
                        class="search-input" 
                        placeholder="Search entities..."
                    >
                </div>
                <div id="entities-container">
                    <div class="loading">No model loaded</div>
                </div>
            </section>
        </aside>
        
        <section class="main-content">
            <div class="view-tabs">
                <button class="tab active" data-view="graph">Graph View</button>
                <button class="tab" data-view="table">Table View</button>
            </div>
            
            <div id="graph-container" class="view-container active"></div>
            <div id="table-container" class="view-container">
                <div class="loading">Select an entity to view details</div>
            </div>
        </section>
    </main>

    <script>
        // Core Data Model Visualizer Application
        
        // File Type Detection
        class FileTypeDetector {
            static detectFileType(file) {
                if (file.name.endsWith('.sqlite') || file.name.endsWith('.db')) {
                    return 'sqlite';
                }
                if (file.name.endsWith('.zip')) {
                    return 'zip_archive';
                }
                if (file.name === 'contents' && file.webkitRelativePath) {
                    return 'xcdatamodel_contents';
                }
                if (file.webkitRelativePath && file.webkitRelativePath.includes('.xcdatamodeld')) {
                    return 'xcdatamodel_bundle';
                }
                return 'unknown';
            }
        }

        // Core Data Model Parser
        class CoreDataModelParser {
            parseXMLContents(xmlString) {
                try {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(xmlString, 'application/xml');
                    
                    // Check for parsing errors
                    const parserError = doc.querySelector('parsererror');
                    if (parserError) {
                        throw new Error('Invalid XML format');
                    }
                    
                    const model = {
                        entities: this.extractEntities(doc),
                        version: doc.documentElement.getAttribute('systemVersion') || 'Unknown',
                        codeGeneration: doc.documentElement.getAttribute('documentVersion') || 'Unknown'
                    };
                    
                    return this.resolveRelationships(model);
                } catch (error) {
                    console.error('Error parsing XML:', error);
                    throw error;
                }
            }
            
            extractEntities(doc) {
                const entities = [];
                const entityElements = doc.querySelectorAll('entity');
                
                entityElements.forEach(element => {
                    const entity = {
                        name: element.getAttribute('name') || 'Unknown',
                        representedClassName: element.getAttribute('representedClassName'),
                        attributes: this.extractAttributes(element),
                        relationships: this.extractRelationships(element),
                        fetchedProperties: this.extractFetchedProperties(element)
                    };
                    entities.push(entity);
                });
                
                return entities;
            }
            
            extractAttributes(entityElement) {
                const attributes = [];
                const attrElements = entityElement.querySelectorAll('attribute');
                
                attrElements.forEach(attr => {
                    attributes.push({
                        name: attr.getAttribute('name') || 'Unknown',
                        type: attr.getAttribute('attributeType') || 'Unknown',
                        optional: attr.getAttribute('optional') === 'YES',
                        defaultValue: attr.getAttribute('defaultValueString'),
                        indexed: attr.getAttribute('indexed') === 'YES'
                    });
                });
                
                return attributes;
            }
            
            extractRelationships(entityElement) {
                const relationships = [];
                const relElements = entityElement.querySelectorAll('relationship');
                
                relElements.forEach(rel => {
                    relationships.push({
                        name: rel.getAttribute('name') || 'Unknown',
                        destination: rel.getAttribute('destinationEntity'),
                        toMany: rel.getAttribute('toMany') === 'YES',
                        optional: rel.getAttribute('optional') === 'YES',
                        deleteRule: rel.getAttribute('deletionRule') || 'No Action',
                        inverse: rel.getAttribute('inverseName')
                    });
                });
                
                return relationships;
            }
            
            resolveRelationships(model) {
                // Add back-references and validate relationships
                model.entities.forEach(entity => {
                    entity.relationships.forEach(rel => {
                        const targetEntity = model.entities.find(e => e.name === rel.destination);
                        if (!targetEntity) {
                            console.warn(`Target entity '${rel.destination}' not found for relationship '${rel.name}' in entity '${entity.name}'`);
                        }
                    });
                });
                
                return model;
            }
            
            extractFetchedProperties(entityElement) {
                const fetchedProperties = [];
                const fpElements = entityElement.querySelectorAll('fetchedProperty');
                
                fpElements.forEach(fp => {
                    fetchedProperties.push({
                        name: fp.getAttribute('name') || 'Unknown',
                        optional: fp.getAttribute('optional') === 'YES'
                    });
                });
                
                return fetchedProperties;
            }
        }

        // Graph Renderer using D3.js
        class DatabaseGraphRenderer {
            constructor(containerId) {
                this.containerId = containerId;
                this.container = d3.select(`#${containerId}`);
                this.container.selectAll('*').remove(); // Clear previous content
                
                this.width = 1200;
                this.height = 800;
                this.selectedNode = null;
                
                this.svg = this.container.append('svg')
                    .attr('width', '100%')
                    .attr('height', '100%')
                    .attr('viewBox', `0 0 ${this.width} ${this.height}`)
                    .attr('preserveAspectRatio', 'xMidYMid meet');
                
                // Add zoom behavior
                this.zoom = d3.zoom()
                    .scaleExtent([0.1, 3])
                    .on('zoom', (event) => {
                        this.g.attr('transform', event.transform);
                    });
                
                this.svg.call(this.zoom);
                
                // Create main group for zoomable content
                this.g = this.svg.append('g');
                
                // Add arrow markers for relationships
                this.addArrowMarkers();
                
                // Create force simulation
                this.simulation = d3.forceSimulation()
                    .force('link', d3.forceLink().id(d => d.id).distance(400))
                    .force('charge', d3.forceManyBody().strength(-2000))
                    .force('center', d3.forceCenter(this.width / 2, this.height / 2))
                    .force('collision', d3.forceCollide().radius(150));
            }
            
            addArrowMarkers() {
                const defs = this.svg.append('defs');
                
                // Standard arrow marker
                defs.append('marker')
                    .attr('id', 'arrowhead')
                    .attr('viewBox', '-0 -5 10 10')
                    .attr('refX', 8)
                    .attr('refY', 0)
                    .attr('orient', 'auto')
                    .attr('markerWidth', 8)
                    .attr('markerHeight', 8)
                    .attr('xoverflow', 'visible')
                    .append('svg:path')
                    .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
                    .attr('fill', '#999')
                    .style('stroke', 'none');
            }
            
            renderModel(model) {
                this.model = model;
                const nodes = this.createNodes(model.entities);
                const links = this.createLinks(model.entities);
                
                this.updateSimulation(nodes, links);
                this.renderLinks(links);
                this.renderNodes(nodes);
            }
            
            createNodes(entities) {
                return entities.map(entity => ({
                    id: entity.name,
                    name: entity.name,
                    attributes: entity.attributes,
                    relationships: entity.relationships,
                    type: 'entity',
                    entity: entity
                }));
            }
            
            createLinks(entities) {
                const links = [];
                entities.forEach(entity => {
                    entity.relationships.forEach(rel => {
                        if (rel.destination) {
                            links.push({
                                source: entity.name,
                                target: rel.destination,
                                type: rel.toMany ? 'one-to-many' : 'one-to-one',
                                label: rel.name,
                                deleteRule: rel.deleteRule,
                                relationship: rel
                            });
                        }
                    });
                });
                return links;
            }
            
            updateSimulation(nodes, links) {
                this.simulation
                    .nodes(nodes)
                    .force('link')
                    .links(links);
                
                this.simulation.alpha(1).restart();
            }
            
            renderNodes(nodes) {
                const nodeGroups = this.g.selectAll('.entity-node')
                    .data(nodes, d => d.id)
                    .join('g')
                    .attr('class', 'entity-node')
                    .call(this.enableDrag());
                
                // Remove old content
                nodeGroups.selectAll('*').remove();
                
                // Calculate node dimensions
                nodes.forEach(node => {
                    node.width = 220;
                    node.height = 60 + (node.attributes.length * 18);
                });
                
                // Add rectangles
                nodeGroups.append('rect')
                    .attr('width', d => d.width)
                    .attr('height', d => d.height)
                    .attr('x', d => -d.width / 2)
                    .attr('y', d => -d.height / 2);
                
                // Add entity name
                nodeGroups.append('text')
                    .attr('class', 'entity-title')
                    .attr('x', 0)
                    .attr('y', d => -d.height / 2 + 20)
                    .attr('text-anchor', 'middle')
                    .text(d => d.name);
                
                // Add separator line
                nodeGroups.append('line')
                    .attr('x1', d => -d.width / 2 + 10)
                    .attr('x2', d => d.width / 2 - 10)
                    .attr('y1', d => -d.height / 2 + 30)
                    .attr('y2', d => -d.height / 2 + 30)
                    .attr('stroke', '#ddd')
                    .attr('stroke-width', 1);
                
                // Add attributes
                nodeGroups.selectAll('.attribute')
                    .data(d => d.attributes)
                    .join('text')
                    .attr('class', 'attribute')
                    .attr('x', d => -100)
                    .attr('y', (d, i, nodes) => {
                        const parentNode = d3.select(nodes[i].parentNode).datum();
                        return -parentNode.height / 2 + 50 + (i * 18);
                    })
                    .text(d => `${d.name}: ${d.type}${d.optional ? '?' : ''}`);
                
                // Add click handlers
                nodeGroups.on('click', (event, d) => {
                    this.selectNode(d);
                    this.updateEntityList();
                    this.updateTableView(d.entity);
                });
                
                // Update positions on simulation tick
                this.simulation.on('tick', () => {
                    nodeGroups.attr('transform', d => `translate(${d.x}, ${d.y})`);
                    this.updateLinkPositions();
                });
            }
            
            renderLinks(links) {
                this.linkElements = this.g.selectAll('.relationship-link')
                    .data(links, d => `${d.source.id || d.source}-${d.target.id || d.target}`)
                    .join('path')
                    .attr('class', d => `relationship-link ${d.type}`)
                    .attr('marker-end', 'url(#arrowhead)');
            }
            
            updateLinkPositions() {
                if (this.linkElements) {
                    this.linkElements.attr('d', d => {
                        // Calculate path from source to target, accounting for node boundaries
                        const source = d.source;
                        const target = d.target;
                        
                        if (!source || !target) return '';
                        
                        const dx = target.x - source.x;
                        const dy = target.y - source.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance === 0) return '';
                        
                        // Calculate edge points on node boundaries
                        const sourceRadius = Math.max(source.width || 100, source.height || 60) / 2;
                        const targetRadius = Math.max(target.width || 100, target.height || 60) / 2;
                        
                        const sourceX = source.x + (dx / distance) * sourceRadius;
                        const sourceY = source.y + (dy / distance) * sourceRadius;
                        const targetX = target.x - (dx / distance) * targetRadius;
                        const targetY = target.y - (dy / distance) * targetRadius;
                        
                        return `M ${sourceX} ${sourceY} L ${targetX} ${targetY}`;
                    });
                }
            }
            
            enableDrag() {
                return d3.drag()
                    .on('start', (event, d) => {
                        if (!event.active) this.simulation.alphaTarget(0.3).restart();
                        d.fx = d.x;
                        d.fy = d.y;
                    })
                    .on('drag', (event, d) => {
                        d.fx = event.x;
                        d.fy = event.y;
                    })
                    .on('end', (event, d) => {
                        if (!event.active) this.simulation.alphaTarget(0);
                        d.fx = null;
                        d.fy = null;
                    });
            }
            
            selectNode(node) {
                // Update visual selection
                this.g.selectAll('.entity-node')
                    .classed('selected', d => d.id === node.id);
                
                this.selectedNode = node;
                
                // Highlight related relationships
                this.g.selectAll('.relationship-link')
                    .classed('selected', d => {
                        return (d.source.id === node.id || d.target.id === node.id);
                    });
            }
            
            updateEntityList() {
                if (this.selectedNode) {
                    const entityItems = document.querySelectorAll('.entity-item');
                    entityItems.forEach(item => {
                        item.classList.toggle('selected', 
                            item.dataset.entityName === this.selectedNode.name);
                    });
                }
            }
            
            updateTableView(entity) {
                const container = document.getElementById('table-container');
                container.innerHTML = `
                    <div class="table-view">
                        <div class="table-header">
                            ${entity.name} - Attributes
                        </div>
                        <div class="table-content">
                            ${entity.attributes.map(attr => `
                                <div class="table-row">
                                    <div class="table-cell name">${attr.name}</div>
                                    <div class="table-cell type">${attr.type}</div>
                                    <div class="table-cell">${attr.optional ? 'Optional' : 'Required'}</div>
                                    <div class="table-cell">${attr.indexed ? 'Indexed' : ''}</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    
                    ${entity.relationships.length > 0 ? `
                    <div class="table-view" style="margin-top: 1rem;">
                        <div class="table-header">
                            ${entity.name} - Relationships
                        </div>
                        <div class="table-content">
                            ${entity.relationships.map(rel => `
                                <div class="table-row">
                                    <div class="table-cell name">${rel.name}</div>
                                    <div class="table-cell type">${rel.destination}</div>
                                    <div class="table-cell">${rel.toMany ? 'To Many' : 'To One'}</div>
                                    <div class="table-cell">${rel.deleteRule}</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    ` : ''}
                `;
            }
            
            resetView() {
                this.svg.transition()
                    .duration(750)
                    .call(this.zoom.transform, d3.zoomIdentity);
            }
        }

        // File Drop Zone Handler
        class FileDropZone {
            constructor(elementId, onFilesProcessed) {
                this.element = document.getElementById(elementId);
                this.onFilesProcessed = onFilesProcessed;
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                this.element.addEventListener('dragover', this.handleDragOver.bind(this));
                this.element.addEventListener('dragleave', this.handleDragLeave.bind(this));
                this.element.addEventListener('drop', this.handleDrop.bind(this));
                this.element.addEventListener('click', this.showFilePicker.bind(this));
                
                // File input handlers
                document.getElementById('file-input').addEventListener('change', (e) => {
                    this.processFiles(Array.from(e.target.files));
                });
                
                document.getElementById('folder-input').addEventListener('change', (e) => {
                    this.processFiles(Array.from(e.target.files));
                });
            }
            
            handleDragOver(event) {
                event.preventDefault();
                this.element.classList.add('drag-over');
            }
            
            handleDragLeave(event) {
                event.preventDefault();
                this.element.classList.remove('drag-over');
            }
            
            async handleDrop(event) {
                event.preventDefault();
                this.element.classList.remove('drag-over');
                
                const files = Array.from(event.dataTransfer.files);
                await this.processFiles(files);
            }
            
            showFilePicker() {
                // This will be handled by button clicks
            }
            
            async processFiles(files) {
                console.log('Processing files:', files.map(f => f.name));
                
                for (const file of files) {
                    const fileType = FileTypeDetector.detectFileType(file);
                    console.log(`File: ${file.name}, Type: ${fileType}`);
                    
                    try {
                        await this.handleFileByType(file, fileType);
                    } catch (error) {
                        console.error(`Error processing file ${file.name}:`, error);
                        this.showError(`Error processing ${file.name}: ${error.message}`);
                    }
                }
            }
            
            async handleFileByType(file, fileType) {
                switch (fileType) {
                    case 'xcdatamodel_contents':
                    case 'xcdatamodel_bundle':
                        await this.handleCoreDataFile(file);
                        break;
                    case 'zip_archive':
                        await this.handleZipFile(file);
                        break;
                    case 'sqlite':
                        await this.handleSQLiteFile(file);
                        break;
                    default:
                        // Try to parse as XML content
                        if (file.name.endsWith('.xml') || file.type === 'text/xml') {
                            await this.handleCoreDataFile(file);
                        } else {
                            throw new Error(`Unsupported file type: ${file.name}`);
                        }
                }
            }
            
            async handleCoreDataFile(file) {
                const xmlText = await file.text();
                const parser = new CoreDataModelParser();
                const model = parser.parseXMLContents(xmlText);
                
                if (this.onFilesProcessed) {
                    this.onFilesProcessed(model);
                }
            }
            
            async handleZipFile(file) {
                const zip = await JSZip.loadAsync(file);
                let foundModel = false;
                
                for (const [path, zipFile] of Object.entries(zip.files)) {
                    if (path.endsWith('contents') && path.includes('.xcdatamodel')) {
                        const xmlText = await zipFile.async('text');
                        const parser = new CoreDataModelParser();
                        const model = parser.parseXMLContents(xmlText);
                        
                        if (this.onFilesProcessed) {
                            this.onFilesProcessed(model);
                        }
                        foundModel = true;
                        break;
                    }
                }
                
                if (!foundModel) {
                    throw new Error('No Core Data model found in ZIP archive');
                }
            }
            
            async handleSQLiteFile(file) {
                // Placeholder for SQLite handling
                console.log('SQLite file handling not yet implemented');
                throw new Error('SQLite file support coming soon');
            }
            
            showError(message) {
                const container = document.getElementById('entities-container');
                container.innerHTML = `<div class="error">${message}</div>`;
            }
        }

        // Main Application Controller
        class AppController {
            constructor() {
                this.currentModel = null;
                this.allEntities = [];
                this.graphRenderer = null;
                this.initializeComponents();
                this.setupEventListeners();
            }
            
            initializeComponents() {
                // Initialize file drop zone
                this.fileDropZone = new FileDropZone('drop-zone', (model) => {
                    this.loadModel(model);
                });
                
                // Initialize graph renderer
                this.graphRenderer = new DatabaseGraphRenderer('graph-container');
            }
            
            setupEventListeners() {
                // Tab switching
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        this.switchView(e.target.dataset.view);
                    });
                });
                
                // Entity search
                const searchInput = document.getElementById('entity-search');
                searchInput.addEventListener('input', (e) => {
                    this.filterEntities(e.target.value);
                });
                
                // Toolbar buttons
                document.getElementById('reset-zoom').addEventListener('click', () => {
                    if (this.graphRenderer) {
                        this.graphRenderer.resetView();
                    }
                });
                
                document.getElementById('export-svg').addEventListener('click', () => {
                    this.exportSVG();
                });
                
                document.getElementById('export-png').addEventListener('click', () => {
                    this.exportPNG();
                });
            }
            
            loadModel(model) {
                console.log('Loading model:', model);
                this.currentModel = model;
                this.allEntities = model.entities;
                
                // Clear search input
                document.getElementById('entity-search').value = '';
                
                // Update entity list
                this.updateEntityList(model.entities);
                
                // Render graph
                if (this.graphRenderer) {
                    this.graphRenderer.renderModel(model);
                }
                
                // Show success message
                const container = document.getElementById('entities-container');
                if (model.entities.length === 0) {
                    container.innerHTML = '<div class="loading">No entities found in model</div>';
                } else {
                    // Entity list will be updated by updateEntityList
                }
            }
            
            filterEntities(searchTerm) {
                if (!this.allEntities || this.allEntities.length === 0) {
                    return;
                }
                
                const filteredEntities = this.allEntities.filter(entity => {
                    // Search in entity name
                    if (entity.name.toLowerCase().includes(searchTerm.toLowerCase())) {
                        return true;
                    }
                    
                    // Search in attribute names
                    if (entity.attributes.some(attr => 
                        attr.name.toLowerCase().includes(searchTerm.toLowerCase())
                    )) {
                        return true;
                    }
                    
                    // Search in relationship names
                    if (entity.relationships.some(rel => 
                        rel.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                        (rel.destination && rel.destination.toLowerCase().includes(searchTerm.toLowerCase()))
                    )) {
                        return true;
                    }
                    
                    return false;
                });
                
                this.updateEntityList(filteredEntities);
            }
            
            updateEntityList(entities) {
                const container = document.getElementById('entities-container');
                
                if (entities.length === 0) {
                    container.innerHTML = '<div class="loading">No entities found</div>';
                    return;
                }
                
                container.innerHTML = entities.map(entity => `
                    <div class="entity-item" data-entity-name="${entity.name}">
                        <div class="entity-name">${entity.name}</div>
                        <div class="entity-info">
                            ${entity.attributes.length} attributes, 
                            ${entity.relationships.length} relationships
                        </div>
                    </div>
                `).join('');
                
                // Add click handlers
                container.querySelectorAll('.entity-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        const entityName = e.currentTarget.dataset.entityName;
                        const entity = entities.find(e => e.name === entityName);
                        
                        if (entity && this.graphRenderer) {
                            const node = { id: entityName, name: entityName, entity: entity };
                            this.graphRenderer.selectNode(node);
                            this.graphRenderer.updateTableView(entity);
                        }
                        
                        // Update selection in entity list
                        container.querySelectorAll('.entity-item').forEach(el => {
                            el.classList.remove('selected');
                        });
                        e.currentTarget.classList.add('selected');
                    });
                });
            }
            
            switchView(viewName) {
                // Update tab states
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.view === viewName);
                });
                
                // Update view containers
                document.querySelectorAll('.view-container').forEach(container => {
                    container.classList.toggle('active', container.id === `${viewName}-container`);
                });
            }
            
            exportSVG() {
                if (!this.graphRenderer) return;
                
                const svgElement = document.querySelector('#graph-container svg');
                if (svgElement) {
                    const serializer = new XMLSerializer();
                    const svgString = serializer.serializeToString(svgElement);
                    const blob = new Blob([svgString], { type: 'image/svg+xml' });
                    saveAs(blob, 'core-data-model.svg');
                }
            }
            
            exportPNG() {
                // This would require html2canvas or similar library
                console.log('PNG export not yet implemented');
            }
        }

        // Initialize application when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            window.app = new AppController();
        });
    </script>
</body>
</html>